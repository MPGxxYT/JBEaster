package me.mortaldev.jbeaster.utils;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.jetbrains.annotations.Nullable;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

public class Utils {

  /**
   * Generates a set of Blocks in the shape of a cube around the given location with specified
   * radius.
   *
   * @param location The center location of the cube
   * @param radius The radius of the cube
   * @return A Set of Blocks representing the cube
   */
  public static Set<Block> cubicAround(Location location, int radius) {
    Set<Block> cube = new HashSet<>();
    Block center = location.getBlock();
    for (int x = -radius; x <= radius; x++) {
      for (int y = -radius; y <= radius; y++) {
        for (int z = -radius; z <= radius; z++) {
          Block b = center.getRelative(x, y, z);
          cube.add(b);
        }
      }
    }
    return cube;
  }

  public static boolean canInventoryHold(Inventory inventory, ItemStack itemStack) {
    int freeSpace = 0;
    for (ItemStack item : inventory.getStorageContents()) {
      if (item == null) {
        freeSpace += itemStack.getMaxStackSize();
      } else if (item.isSimilar(itemStack)) {
        freeSpace += itemStack.getMaxStackSize() - item.getAmount();
      }
    }
    return freeSpace >= itemStack.getAmount();
  }

  /**
   * Converts a location to a serialized string. The format is
   * "w:<world_name>,x:<x>,y:<y>,z:<z>,p:<pitch>,y:<yaw>".
   *
   * @param location The location to serialize.
   * @return The serialized string.
   */
  public static String locationSerialize(Location location) {
    return "w:"
        + location.getWorld().getName()
        + ",x:"
        + location.getX()
        + ",y:"
        + location.getY()
        + ",z:"
        + location.getZ()
        + ",p:"
        + location.getPitch()
        + ",y:"
        + location.getYaw();
  }

  /**
   * Deserializes a string representation of a location, generated by {@link
   * #locationSerialize(Location)}, into the actual location.
   *
   * @param serialized The serialized location string.
   * @return The deserialized location.
   */
  public static Location locationDeserialize(String serialized) {
    String[] parts = serialized.split(",");
    return new Location(
        Bukkit.getWorld(parts[0].substring(2)),
        Double.parseDouble(parts[1].substring(2)),
        Double.parseDouble(parts[2].substring(2)),
        Double.parseDouble(parts[3].substring(2)),
        Float.parseFloat(parts[4].substring(2)),
        Float.parseFloat(parts[5].substring(2)));
  }

  /**
   * Determines whether a given location is within a defined area.
   *
   * @param loc The location to check.
   * @param loc1 The first corner of the defined area.
   * @param loc2 The second corner of the defined area.
   * @return {@code true} if the location is within the defined area, {@code false} otherwise.
   */
  public static boolean locationIsWithin(Location loc, Location loc1, Location loc2) {
    double x1 = Math.min(loc1.getX(), loc2.getX());
    double y1 = Math.min(loc1.getY(), loc2.getY());
    double z1 = Math.min(loc1.getZ(), loc2.getZ());
    double x2 = Math.max(loc1.getX(), loc2.getX());
    double y2 = Math.max(loc1.getY(), loc2.getY());
    double z2 = Math.max(loc1.getZ(), loc2.getZ());
    Location l1 = new Location(loc1.getWorld(), x1, y1, z1);
    Location l2 = new Location(loc1.getWorld(), x2, y2, z2);
    return loc.getBlockX() >= l1.getBlockX()
        && loc.getBlockX() <= l2.getBlockX()
        && loc.getBlockY() >= l1.getBlockY()
        && loc.getBlockY() <= l2.getBlockY()
        && loc.getBlockZ() >= l1.getBlockZ()
        && loc.getBlockZ() <= l2.getBlockZ();
  }

  /**
   * Returns a new LinkedHashMap with the same key-value mappings as the given original
   * LinkedHashMap, but in reverse order. The original LinkedHashMap is not modified.
   *
   * @param original The LinkedHashMap to reverse.
   * @return A new LinkedHashMap with the same mappings, but in reverse order.
   */
  public static <K, V> LinkedHashMap<K, V> reverseMap(LinkedHashMap<K, V> original) {

    LinkedHashMap<K, V> reversed = new LinkedHashMap<>();
    ListIterator<Map.Entry<K, V>> iterator =
        new ArrayList<>(original.entrySet()).listIterator(original.size());

    while (iterator.hasPrevious()) {
      Map.Entry<K, V> entry = iterator.previous();
      reversed.put(entry.getKey(), entry.getValue());
    }

    return reversed;
  }
}
